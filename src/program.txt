ADDI R1 R0 2
ADDI R2 R0 3
ADDI R3 R0 4
ADDI R4 R0 5
ADDI R5 R1 10  // R5 = R1 + 10 = 2 + 10 = 12
SUB R6 R2 R1   // R6 = R2 - R1 = 3 - 2 = 1
MULI R7 R3 3   // R7 = R3 * 3 = 4 * 3 = 12
ANDI R8 R4 1   // R8 = R4 & 1 = 5 & 1 = 1 (bitwise AND)
ORI R9 R4 1    // R9 = R4 | 1 = 5 | 1 = 5 (bitwise OR)
SLL R10 R4 1   // R10 = R4 << 1 = 5 << 1 = 10 (logical shift left)
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
ADD R0 R0 R0
SRL R11 R10 1  // R11 = R10 >> 1 = 10 >> 1 = 5 (logical shift right)
SW R6 R12 1700    // Stores value in R6 at MEM[R12 + 1]
LW R13 R12 1700   // Load word from MEM[R12 + 1] into R13
BNE R1 R2 3    // If R1 != R2, then branch to the instruction 3 steps ahead (it will not branch as R1 is equal to R2)
ADD R14 R1 R2  // R14 = R1 + R2 = 2 + 3 = 5
J 4            // Jump to the instruction at index 4 (ORI R9 R4 1)